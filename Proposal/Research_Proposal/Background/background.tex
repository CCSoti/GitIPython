\subsection{Scientific Programming}
\subsection{Python in Scientific Programming}
\subsection{IPython in Scientific Programming}

The IPython notebook was developed in 2011
by a team of researchers led by Fernando Pérez,
a data scientist at the University of California,
Berkeley, and computational physicist Brian
Granger at California Polytechnic State University
in San Luis Obispo. “We built it by solving
problems that we ourselves had as researchers
and educators,” says Pérez.

Pérez and Granger saw that data scientists
found it hard to share detailed but understandable
descriptions of their raw code that would
allow others to build on their research. That is
partly because many scientists in computationintensive
fields write code in an iterative and
piecemeal fashion as each analysis reveals new
insight and spins off multiple lines of inquiry.
Keeping track of the different versions of code
that produce various figures, and linking those
files with explanatory notes, is a headache.
And what gets published is usually not detailed
enough for the reader to follow up on. “In my
own computational physics work,” says Granger,
“a high-level description of the algorithm that
goes into the paper is light years away from
the details that are written in the code. Without
those details, there is no way that someone
could reproduce it in a reasonable time scale.”

\subsubsection{Contributions}

At the University of Texas at Austin, Tal Yarkoni
uses the IPython notebook to run automated
meta-analyses of brain imaging studies to
uncover patterns of neural activity involved in
language processing, emotion and other processes.
The psychoinformatician plans to publish
the notebooks as companions to his future
journal articles. “The more complicated the
analyses, the greater the benefits of being able to convey all that in one simple document,” he says.
\cite{shen2014interactive}

\subsection{Usage of Laboratory notebooks in researches}
\subsection{IPython in GitHub}
present an overview of relevant previous work including articles, books, and existing software products. Critically evaluate the strengths and weaknesses of the previous work.